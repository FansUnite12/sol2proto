// Copyright 2018 AMIS Technologies
// This file is part of the sol2proto
//
// The sol2proto is free software: you can redistribute it and/or modify
// it under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// The sol2proto is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
// GNU Lesser General Public License for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with the sol2proto. If not, see <http://www.gnu.org/licenses/>.

package main

import (
	"bytes"
	"fmt"
	"html/template"
	"io/ioutil"
	"os"
	"path"
	"path/filepath"
	"sort"
	"strings"

	"github.com/ethereum/go-ethereum/accounts/abi"
	flag "github.com/spf13/pflag"

	"github.com/getamis/sirius/util"
	"github.com/getamis/sol2proto/grpc"
)

var (
	GitVersion string = "dirty"
	abiFiles   []string
	pkgName    string
)

func init() {
	flag.StringArrayVar(&abiFiles, "abi", []string{}, "ABI files generated by solc")
	flag.StringVar(&pkgName, "pkg", "pb", "go package name for the generated proto")
}

func main() {
	flag.Parse()

	if len(abiFiles) == 0 {
		fmt.Printf("Please specify the abi files\n")
		os.Exit(-1)
	}

	if pkgName == "" {
		fmt.Printf("Please specify package name\n")
		os.Exit(-1)
	}

	// generate messages proto file
	messages := grpc.Service{
		GeneratorVersion: GitVersion,
		Package:          pkgName,
		Name:             "Messages",
		Messages:         make(map[string]grpc.Message),
		Sources:          make([]string, len(abiFiles)),
	}

	for i, f := range abiFiles {
		abiString, err := ioutil.ReadFile(f)
		if err != nil {
			fmt.Printf("Failed to read input ABI: %v\n", err)
			os.Exit(-1)
		}

		contractAbi, err := abi.JSON(bytes.NewReader(abiString))
		if err != nil {
			fmt.Printf("Failed to parse contract ABI: %v\n", err)
			os.Exit(-1)
		}

		srvName := util.ToCamelCase(strings.TrimSuffix(filepath.Base(f), filepath.Ext(filepath.Base(f))))
		_, source := path.Split(f)
		messages.Sources[i] = source
		service := grpc.Service{
			GeneratorVersion: GitVersion,
			Package:          pkgName,
			Name:             srvName,
			Sources:          []string{source},
		}

		methods, requiredMsgs := grpc.ParseMethods(contractAbi.Methods)
		service.Methods = append(service.Methods, methods...)

		for _, m := range requiredMsgs {
			messages.Messages[m.Name] = m
		}

		events, requiredMsgs := grpc.ParseEvents(contractAbi.Events)
		service.Events = append(service.Events, events...)

		for _, m := range requiredMsgs {
			messages.Messages[m.Name] = m
		}

		sort.Sort(service.Methods)
		sort.Sort(service.Events)
		sort.Sort(service.Sources)
		writeServiceToFile(srvName, grpc.ServiceTemplate, service)
	}

	sort.Sort(messages.Sources)
	writeServiceToFile(messages.Name, grpc.MessagesTemplate, messages)
}

// writeServiceToFile writes the service into file
func writeServiceToFile(srvName, serviceTemplate string, service interface{}) {
	template, err := template.New("proto").Parse(serviceTemplate)
	if err != nil {
		fmt.Printf("Failed to parse template: %v\n", err)
		os.Exit(-1)
	}

	filename := fmt.Sprintf("%v.proto", util.ToUnderScore(srvName))
	file, err := os.Create(filename)
	if err != nil {
		fmt.Printf("Failed to create file: %v, %v\n", filename, err)
		os.Exit(-1)
	}
	err = template.Execute(file, service)
	if err != nil {
		fmt.Printf("Failed to render template: %v\n", err)
		os.Exit(-1)
	}
}
